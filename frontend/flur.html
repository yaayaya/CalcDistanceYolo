<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlurPaint - äº’å‹•è—è¡“è£ç½®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            overflow: hidden;
        }

        #display-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            object-fit: cover; /* å¡«æ»¿æ•´å€‹è¢å¹•ï¼Œé¿å…é»‘é‚Šå’Œè·³å‹• */
            image-rendering: pixelated; /* ä½è§£æåº¦æ™‚ä¿æŒåƒç´ åŒ–æ•ˆæœ */
            transform: translateZ(0); /* å•Ÿç”¨ GPU åŠ é€Ÿï¼Œæ¸›å°‘æŠ–å‹• */
            will-change: auto; /* é¿å…éåº¦å„ªåŒ–å°è‡´çš„å•é¡Œ */
        }

        /* é™¤éŒ¯è³‡è¨Šè¦†è“‹å±¤ */
        #debug-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 8px;
            z-index: 1000;
            display: none; /* é è¨­éš±è— */
            pointer-events: none;
        }

        #debug-overlay.active {
            display: block;
        }

        #debug-overlay .debug-item {
            margin: 5px 0;
        }

        #debug-overlay .debug-label {
            color: #0ff;
        }

        #debug-overlay .debug-value {
            color: #fff;
            font-weight: bold;
        }

        /* é€£ç·šç‹€æ…‹æŒ‡ç¤ºå™¨ */
        #connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            display: none;
        }

        #connection-status.connecting {
            background: #f59e0b;
            color: #fff;
            display: block;
        }

        #connection-status.connected {
            background: #10b981;
            color: #fff;
            display: block;
            animation: fadeOut 2s forwards;
        }

        #connection-status.disconnected {
            background: #ef4444;
            color: #fff;
            display: block;
        }

        @keyframes fadeOut {
            0%, 80% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                display: none;
            }
        }

        /* å±•è¦½æ¨¡å¼èªªæ˜ */
        #exhibition-info {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 18px;
            text-align: center;
            z-index: 1000;
            animation: pulse 2s infinite;
            display: none; /* é è¨­éš±è— */
        }

        #exhibition-info.active {
            display: block;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 0.6;
            }
            50% {
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <!-- Canvas é¡¯ç¤ºå€ -->
    <div id="canvas-container">
        <canvas id="display-canvas"></canvas>
    </div>

    <!-- é™¤éŒ¯è³‡è¨Šè¦†è“‹å±¤ -->
    <div id="debug-overlay">
        <div class="debug-item">
            <span class="debug-label">é€£ç·šç‹€æ…‹:</span>
            <span class="debug-value" id="debug-connection">æœªé€£ç·š</span>
        </div>
        <div class="debug-item">
            <span class="debug-label">åµæ¸¬è·é›¢:</span>
            <span class="debug-value" id="debug-distance">-- cm</span>
        </div>
        <div class="debug-item">
            <span class="debug-label">åµæ¸¬äººæ•¸:</span>
            <span class="debug-value" id="debug-count">0</span>
        </div>
        <div class="debug-item">
            <span class="debug-label">ç›®æ¨™è§£æåº¦:</span>
            <span class="debug-value" id="debug-resolution">-- x --</span>
        </div>
        <div class="debug-item">
            <span class="debug-label">ç•¶å‰è§£æåº¦:</span>
            <span class="debug-value" id="debug-current-res">-- x --</span>
        </div>
        <div class="debug-item">
            <span class="debug-label">FPS:</span>
            <span class="debug-value" id="debug-fps">--</span>
        </div>
        <div class="debug-item">
            <span class="debug-label">JPEG å“è³ª:</span>
            <span class="debug-value" id="debug-quality">--</span>
        </div>
        <div class="debug-item">
            <span class="debug-label">æ¨¡ç³ŠåŠå¾‘:</span>
            <span class="debug-value" id="debug-blur">--</span>
        </div>
        <div class="debug-item">
            <span class="debug-label">åœ–å±¤é€æ˜åº¦:</span>
            <span class="debug-value" id="debug-opacity">--</span>
        </div>
    </div>

    <!-- é€£ç·šç‹€æ…‹æŒ‡ç¤ºå™¨ -->
    <div id="connection-status">é€£ç·šä¸­...</div>

    <!-- å±•è¦½æ¨¡å¼èªªæ˜ -->
    <div id="exhibition-info">
        è«‹é è¿‘æˆ–é é›¢æ„Ÿæ‡‰å™¨,é«”é©—å½±åƒè§£æåº¦çš„è®ŠåŒ–
    </div>

    <script>
        // ===== å…¨åŸŸè®Šæ•¸ =====
        let ws = null;
        let config = null;
        let canvas = null;
        let ctx = null;
        
        // ç•¶å‰å½±åƒè§£æåº¦ (å¾å¾Œç«¯æ¥æ”¶)
        let currentResolution = { width: 1920, height: 1080 };
        
        // ç•¶å‰è·é›¢èˆ‡æ¨¡ç³Šåƒæ•¸
        let currentDistance = 0;
        let targetDistance = 0;  // ç›®æ¨™è·é›¢
        let smoothedDistance = 0; // å¹³æ»‘å¾Œçš„è·é›¢
        let currentBlurRadius = 0;
        let currentOpacity = 0;
        
        // è·é›¢å¹³æ»‘éæ¸¡é…ç½®ï¼ˆå¾ config è¼‰å…¥ï¼‰
        let DISTANCE_SMOOTH_SPEED = 0.15;
        let DISTANCE_CHANGE_THRESHOLD = 10;
        
        // FPS è¨ˆç®—
        let frameCount = 0;
        let lastFpsUpdate = performance.now();
        let currentFps = 0;
        let lastFrameTime = 0;

        // ===== åˆå§‹åŒ– =====
        document.addEventListener('DOMContentLoaded', async () => {
            canvas = document.getElementById('display-canvas');
            ctx = canvas.getContext('2d', { alpha: false });
            
            // è¼‰å…¥é…ç½®
            await loadConfig();
            
            // å¥—ç”¨é¡¯ç¤ºè¨­å®š
            applyDisplaySettings();
            
            // å»ºç«‹ WebSocket é€£ç·š
            connectWebSocket();
            
            // ç¹«å®šç†±éµ
            bindHotkeys();
        });

        // ===== è¼‰å…¥é…ç½® =====
        async function loadConfig() {
            try {
                const response = await fetch('/api/project-config');
                const result = await response.json();
                
                if (result.status === 'success') {
                    config = result.data;
                    
                    // è¼‰å…¥è·é›¢å¹³æ»‘åƒæ•¸
                    if (config.distance_smoothing) {
                        DISTANCE_SMOOTH_SPEED = config.distance_smoothing.smooth_speed || 0.15;
                        DISTANCE_CHANGE_THRESHOLD = config.distance_smoothing.change_threshold || 10;
                    }
                    
                    console.log('âœ… é…ç½®å·²è¼‰å…¥:', config);
                    console.log(`ğŸ“Š è·é›¢å¹³æ»‘: é€Ÿåº¦=${DISTANCE_SMOOTH_SPEED}, é–¾å€¼=${DISTANCE_CHANGE_THRESHOLD}cm`);
                } else {
                    console.error('âŒ è¼‰å…¥é…ç½®å¤±æ•—');
                    useDefaultConfig();
                }
            } catch (error) {
                console.error('âŒ è¼‰å…¥é…ç½®éŒ¯èª¤:', error);
                useDefaultConfig();
            }
        }

        function useDefaultConfig() {
            config = {
                blur_control: {
                    min_resolution_width: 320,
                    max_resolution_width: 1920,
                    acceleration_time: 500,
                    deceleration_time: 1000,
                    movement_threshold: 10,
                    activation_delay: 200,
                    deactivation_delay: 500,
                    sample_rate: 30
                },
                distance_mapping: {
                    min_distance: 50,
                    max_distance: 500,
                    easing_function: "linear"
                },
                display: {
                    debug_mode: false,
                    exhibition_mode: true,
                    show_fps: false,
                    show_distance: false
                },
                blur_overlay: {
                    enabled: false,
                    min_distance: 70,
                    max_distance: 120,
                    min_blur_radius: 0,
                    max_blur_radius: 8,
                    min_opacity: 0,
                    max_opacity: 0.3,
                    overlay_color: "#888888",
                    easing_function: "ease-out",
                    layer_count: 3,
                    blend_mode: "normal"
                },
                canvas_filter: {
                    enabled: true,
                    min_distance: 70,
                    max_distance: 120,
                    min_blur_radius: 0,
                    max_blur_radius: 5,
                    easing_function: "ease-out",
                    noise_enabled: true,
                    min_noise_intensity: 0,
                    max_noise_intensity: 0.08,
                    noise_blend_mode: "overlay"
                },
                distance_smoothing: {
                    enabled: true,
                    smooth_speed: 0.15,
                    change_threshold: 10
                }
            };
        }

        // ===== å¥—ç”¨é¡¯ç¤ºè¨­å®š =====
        function applyDisplaySettings() {
            const debugOverlay = document.getElementById('debug-overlay');
            const exhibitionInfo = document.getElementById('exhibition-info');
            
            if (config.display.debug_mode) {
                debugOverlay.classList.add('active');
                exhibitionInfo.classList.remove('active');
            } else if (config.display.exhibition_mode) {
                debugOverlay.classList.remove('active');
                exhibitionInfo.classList.add('active');
            } else {
                debugOverlay.classList.remove('active');
                exhibitionInfo.classList.remove('active');
            }
        }

        // ===== WebSocket é€£ç·š =====
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/flur`;
            
            updateConnectionUI('connecting');
            
            try {
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    console.log('âœ… WebSocket å·²é€£ç·š');
                    updateConnectionUI('connected');
                    updateDebugInfo('connection', 'å·²é€£ç·š');
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleFrameData(data);
                };
                
                ws.onerror = (error) => {
                    console.error('âŒ WebSocket éŒ¯èª¤:', error);
                    updateConnectionUI('disconnected');
                    updateDebugInfo('connection', 'é€£ç·šéŒ¯èª¤');
                };
                
                ws.onclose = () => {
                    console.log('â¹ WebSocket å·²æ–·ç·š');
                    updateConnectionUI('disconnected');
                    updateDebugInfo('connection', 'æœªé€£ç·š');
                    
                    // 5ç§’å¾Œè‡ªå‹•é‡é€£
                    setTimeout(connectWebSocket, 5000);
                };
                
            } catch (error) {
                console.error('âŒ å»ºç«‹ WebSocket å¤±æ•—:', error);
                updateConnectionUI('disconnected');
            }
        }

        // ===== è™•ç†å½±åƒå¹€è³‡æ–™ =====
        function handleFrameData(data) {
            if (data.type !== 'frame_data') return;
            
            // æ›´æ–°ç›®æ¨™è·é›¢ï¼ˆä½¿ç”¨å¹³æ»‘éæ¸¡ï¼‰
            targetDistance = data.distance || 0;
            
            // åˆå§‹åŒ–å¹³æ»‘è·é›¢
            if (smoothedDistance === 0) {
                smoothedDistance = targetDistance;
            }
            
            // å¹³æ»‘è·é›¢éæ¸¡ (ç·šæ€§æ’å€¼)
            const distanceDiff = Math.abs(targetDistance - smoothedDistance);
            if (distanceDiff > DISTANCE_CHANGE_THRESHOLD) {
                // è·é›¢è®ŠåŒ–è¼ƒå¤§æ™‚ä½¿ç”¨å¹³æ»‘éæ¸¡
                smoothedDistance += (targetDistance - smoothedDistance) * DISTANCE_SMOOTH_SPEED;
            } else {
                // è·é›¢è®ŠåŒ–å°æ™‚ç›´æ¥ä½¿ç”¨ç›®æ¨™è·é›¢
                smoothedDistance = targetDistance;
            }
            
            // ä½¿ç”¨å¹³æ»‘å¾Œçš„è·é›¢
            currentDistance = smoothedDistance;
            
            // æ›´æ–°ç•¶å‰è§£æåº¦ (å¾å¾Œç«¯æ¥æ”¶)
            if (data.resolution) {
                currentResolution = {
                    width: data.resolution.width,
                    height: data.resolution.height
                };
            }
            
            // æ›´æ–°é™¤éŒ¯è³‡è¨Š
            updateDebugInfo('distance', `${targetDistance.toFixed(1)} cm â†’ ${smoothedDistance.toFixed(1)} cm`);
            updateDebugInfo('count', data.total_count || 0);
            updateDebugInfo('resolution', `${currentResolution.width} x ${currentResolution.height}`);
            updateDebugInfo('quality', data.quality || '--');
            
            // è§£ç¢¼ä¸¦ç¹ªè£½å½±åƒ
            const img = new Image();
            img.onload = () => {
                const now = performance.now();
                
                drawFrame(img);
                
                // è¨ˆç®— FPS
                frameCount++;
                const elapsed = now - lastFpsUpdate;
                if (elapsed >= 1000) {
                    currentFps = Math.round((frameCount * 1000) / elapsed);
                    frameCount = 0;
                    lastFpsUpdate = now;
                    updateDebugInfo('fps', currentFps);
                }
            };
            img.src = 'data:image/jpeg;base64,' + data.image;
        }

        // ===== ç¹ªè£½å½±åƒå¹€ =====
        function drawFrame(img) {
            // æª¢æŸ¥æ˜¯å¦éœ€è¦æ›´æ–° Canvas å°ºå¯¸
            const needsResize = canvas.width !== currentResolution.width || canvas.height !== currentResolution.height;
            
            if (needsResize) {
                // ç«‹å³æ›´æ–°å°ºå¯¸ï¼Œä¸ä½¿ç”¨å‹•ç•«æˆ–éæ¸¡
                canvas.width = currentResolution.width;
                canvas.height = currentResolution.height;
            }
            
            // å¥—ç”¨ Canvas Filter æ¨¡ç³Šï¼ˆGPU åŠ é€Ÿï¼‰
            if (config.canvas_filter && config.canvas_filter.enabled) {
                applyCanvasFilter(img);
            } else {
                // ç¹ªè£½æ–°å½±åƒï¼Œå¡«æ»¿æ•´å€‹ Canvasï¼ˆè‡ªå‹•è¦†è“‹èˆŠå…§å®¹ï¼‰
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            }
            
            // ç¹ªè£½æ¨¡ç³Šåœ–å±¤ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
            if (config.blur_overlay && config.blur_overlay.enabled) {
                drawBlurOverlay();
            }
            
            // æ›´æ–°é™¤éŒ¯è³‡è¨Š
            if (needsResize) {
                updateDebugInfo('current-res', `${canvas.width} x ${canvas.height}`);
            }
        }

        // ===== ç¹ªè£½æ¨¡ç³Šåœ–å±¤ =====
        function drawBlurOverlay() {
            const overlay = config.blur_overlay;
            
            // è¨ˆç®—ç•¶å‰è·é›¢å°æ‡‰çš„æ¨¡ç³Šåƒæ•¸
            const normalizedDistance = calculateNormalizedDistance(
                currentDistance,
                overlay.min_distance,
                overlay.max_distance
            );
            
            // ä½¿ç”¨ç·©å‹•å‡½æ•¸
            const easedValue = applyEasing(normalizedDistance, overlay.easing_function);
            
            // è¨ˆç®—æ¨¡ç³ŠåŠå¾‘å’Œé€æ˜åº¦ï¼ˆè·é›¢è¶Šè¿‘ï¼Œæ¨¡ç³Šè¶Šå¼·ï¼‰
            currentBlurRadius = lerp(overlay.max_blur_radius, overlay.min_blur_radius, easedValue);
            currentOpacity = lerp(overlay.max_opacity, overlay.min_opacity, easedValue);
            
            // æ›´æ–°é™¤éŒ¯è³‡è¨Š
            updateDebugInfo('blur', `${currentBlurRadius.toFixed(1)} px`);
            updateDebugInfo('opacity', `${(currentOpacity * 100).toFixed(1)}%`);
            
            // åªåœ¨æœ‰æ•ˆæœæ™‚ç¹ªè£½
            if (currentBlurRadius > 0 && currentOpacity > 0) {
                // å¤šå±¤ç¹ªè£½ä»¥å¢å¼·æŸ”å’Œæ•ˆæœ
                const layerCount = overlay.layer_count || 3;
                const opacityPerLayer = currentOpacity / layerCount;
                
                for (let i = 0; i < layerCount; i++) {
                    ctx.save();
                    
                    // è¨­å®šæ··åˆæ¨¡å¼
                    ctx.globalCompositeOperation = overlay.blend_mode || 'normal';
                    ctx.globalAlpha = opacityPerLayer;
                    
                    // è¨­å®šæ¨¡ç³Šæ¿¾é¡
                    const blurPerLayer = currentBlurRadius * (1 - i / layerCount * 0.3);
                    ctx.filter = `blur(${blurPerLayer}px)`;
                    
                    // ç¹ªè£½åŠé€æ˜è‰²å¡Š
                    ctx.fillStyle = overlay.overlay_color || '#888888';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.restore();
                }
                
                // é‡è¨­æ¿¾é¡å’Œé€æ˜åº¦
                ctx.filter = 'none';
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        // ===== å¥—ç”¨ Canvas Filter æ¨¡ç³Šï¼ˆGPU åŠ é€Ÿï¼‰=====
        function applyCanvasFilter(img) {
            const filterConfig = config.canvas_filter;
            
            // è¨ˆç®—ç•¶å‰è·é›¢å°æ‡‰çš„æ¨¡ç³Šåƒæ•¸
            const normalizedDistance = calculateNormalizedDistance(
                currentDistance,
                filterConfig.min_distance,
                filterConfig.max_distance
            );
            
            // ä½¿ç”¨ç·©å‹•å‡½æ•¸
            const easedValue = applyEasing(normalizedDistance, filterConfig.easing_function || 'ease-out');
            
            // è¨ˆç®—æ¨¡ç³ŠåŠå¾‘ï¼ˆè·é›¢è¶Šè¿‘ï¼Œæ¨¡ç³Šè¶Šå¼·ï¼‰
            const blurRadius = lerp(filterConfig.max_blur_radius, filterConfig.min_blur_radius, easedValue);
            
            // å¥—ç”¨ Canvas filterï¼ˆGPU åŠ é€Ÿï¼‰
            ctx.save();
            if (blurRadius > 0) {
                ctx.filter = `blur(${blurRadius}px)`;
            }
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.filter = 'none';
            ctx.restore();
            
            // ç–ŠåŠ å™ªé»å±¤ï¼ˆå¢å¼·ç´°ç¯€ï¼‰
            if (filterConfig.noise_enabled) {
                const noiseIntensity = lerp(
                    filterConfig.max_noise_intensity,
                    filterConfig.min_noise_intensity,
                    easedValue
                );
                if (noiseIntensity > 0) {
                    drawNoiseLayer(noiseIntensity, filterConfig.noise_blend_mode || 'overlay');
                }
            }
            
            // æ›´æ–°é™¤éŒ¯è³‡è¨Š
            updateDebugInfo('blur', `Canvas Filter: ${blurRadius.toFixed(1)} px`);
        }

        // ===== ç¹ªè£½å™ªé»å±¤ =====
        let noiseCanvas = null;
        let noiseCtx = null;
        
        function drawNoiseLayer(intensity, blendMode) {
            // ä½¿ç”¨é›¢å± Canvas å¿«å–å™ªé»ï¼Œæå‡æ•ˆèƒ½
            if (!noiseCanvas || noiseCanvas.width !== canvas.width || noiseCanvas.height !== canvas.height) {
                noiseCanvas = document.createElement('canvas');
                noiseCanvas.width = canvas.width;
                noiseCanvas.height = canvas.height;
                noiseCtx = noiseCanvas.getContext('2d', { alpha: false });
            }
            
            // å»ºç«‹å™ªé»åœ–æ¡ˆï¼ˆé™ä½è§£æåº¦ä»¥æå‡æ•ˆèƒ½ï¼‰
            const scale = 0.5; // å™ªé»è§£æåº¦ç¸®æ”¾
            const noiseData = noiseCtx.createImageData(canvas.width * scale, canvas.height * scale);
            const pixels = noiseData.data;
            const intensityValue = 255 * intensity;
            
            // æ‰¹æ¬¡ç”Ÿæˆå™ªé»
            for (let i = 0; i < pixels.length; i += 4) {
                const noise = (Math.random() - 0.5) * intensityValue;
                const gray = 128 + noise;
                pixels[i] = gray;     // R
                pixels[i + 1] = gray; // G
                pixels[i + 2] = gray; // B
                pixels[i + 3] = 255;  // A
            }
            
            // å°‡å™ªé»ç¹ªè£½åˆ°é›¢å± Canvas
            noiseCtx.putImageData(noiseData, 0, 0);
            
            // ç–ŠåŠ å™ªé»åˆ°ä¸» Canvas
            ctx.save();
            ctx.globalCompositeOperation = blendMode;
            ctx.drawImage(noiseCanvas, 0, 0, canvas.width, canvas.height);
            ctx.restore();
            ctx.globalCompositeOperation = 'source-over';
        }

        // ===== è¨ˆç®—æ­£è¦åŒ–è·é›¢ (0-1) =====
        function calculateNormalizedDistance(distance, minDist, maxDist) {
            if (distance <= minDist) return 0;
            if (distance >= maxDist) return 1;
            return (distance - minDist) / (maxDist - minDist);
        }

        // ===== ç·©å‹•å‡½æ•¸ =====
        function applyEasing(t, easingType) {
            switch (easingType) {
                case 'linear':
                    return t;
                case 'ease-in':
                    return t * t;
                case 'ease-out':
                    return 1 - Math.pow(1 - t, 2);
                case 'ease-in-out':
                    return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                default:
                    return t;
            }
        }

        // ===== ç·šæ€§æ’å€¼ =====
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        // ===== æ›´æ–°é€£ç·šç‹€æ…‹ UI =====
        function updateConnectionUI(status) {
            const statusElement = document.getElementById('connection-status');
            statusElement.className = status;
            
            const statusText = {
                'connecting': 'é€£ç·šä¸­...',
                'connected': 'å·²é€£ç·š',
                'disconnected': 'é€£ç·šä¸­æ–·'
            };
            
            statusElement.textContent = statusText[status] || 'æœªçŸ¥ç‹€æ…‹';
        }

        // ===== æ›´æ–°é™¤éŒ¯è³‡è¨Š =====
        function updateDebugInfo(key, value) {
            const element = document.getElementById(`debug-${key}`);
            if (element) {
                element.textContent = value;
            }
        }

        // ===== ç¶å®šç†±éµ =====
        function bindHotkeys() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+Shift+D: åˆ‡æ›é™¤éŒ¯æ¨¡å¼
                if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                    config.display.debug_mode = !config.display.debug_mode;
                    applyDisplaySettings();
                    e.preventDefault();
                }
                
                // Ctrl+Shift+E: åˆ‡æ›å±•è¦½æ¨¡å¼
                if (e.ctrlKey && e.shiftKey && e.key === 'E') {
                    config.display.exhibition_mode = !config.display.exhibition_mode;
                    applyDisplaySettings();
                    e.preventDefault();
                }
            });
        }
    </script>
</body>
</html>
